/**
 * @file Emulator.hpp
 * @brief Digitizer emulator component for testing and demos
 *
 * Emulator generates synthetic event data compatible with EventData/MinimalEventData.
 * Each instance has a fixed Module number, useful for multi-module testing.
 */

#ifndef DELILA_COMPONENT_EMULATOR_HPP
#define DELILA_COMPONENT_EMULATOR_HPP

#include <delila/core/Command.hpp>
#include <delila/core/ComponentState.hpp>
#include <delila/core/ComponentStatus.hpp>
#include <delila/core/IDataComponent.hpp>

#include <atomic>
#include <memory>
#include <mutex>
#include <random>
#include <string>
#include <thread>
#include <utility>
#include <vector>

namespace DELILA {

// Forward declarations
namespace Net {
class ZMQTransport;
class DataProcessor;
}  // namespace Net

/**
 * @brief Data generation mode
 */
enum class EmulatorDataMode {
  Minimal,  ///< MinimalEventData (22 bytes) - fast, lightweight
  Full      ///< EventData with optional waveform - full features
};

/**
 * @brief Digitizer emulator for testing and development
 *
 * Generates synthetic event data at configurable rates.
 * Each Emulator instance represents a single module with a fixed module number.
 *
 * Features:
 * - Configurable event rate
 * - Configurable channel count
 * - Configurable energy range
 * - Minimal or Full data mode
 * - Fixed module number per instance
 *
 * Thread model:
 * - Main thread: State management
 * - Generation thread: Creates and sends events
 */
class Emulator : public IDataComponent {
 public:
  Emulator();
  ~Emulator() override;

  // Disable copy
  Emulator(const Emulator&) = delete;
  Emulator& operator=(const Emulator&) = delete;

  // === IComponent interface ===
  bool Initialize(const std::string& config_path) override;
  void Run() override;
  void Shutdown() override;
  ComponentState GetState() const override;
  std::string GetComponentId() const override;
  ComponentStatus GetStatus() const override;

  // === IDataComponent interface ===
  void SetInputAddresses(const std::vector<std::string>& addresses) override;
  void SetOutputAddresses(const std::vector<std::string>& addresses) override;
  std::vector<std::string> GetInputAddresses() const override;
  std::vector<std::string> GetOutputAddresses() const override;

  // === Command channel ===
  void SetCommandAddress(const std::string& address) override;
  std::string GetCommandAddress() const override;
  void StartCommandListener() override;
  void StopCommandListener() override;

  // === Public control methods ===
  bool Arm();
  bool Start(uint32_t run_number);
  bool Stop(bool graceful);
  void Reset();

  // === Configuration ===
  void SetComponentId(const std::string& id);

  /**
   * @brief Set the module number for this emulator
   * @param module Module ID (0-255)
   *
   * This value is fixed for all events generated by this instance.
   */
  void SetModuleNumber(uint8_t module);
  uint8_t GetModuleNumber() const;

  /**
   * @brief Set the number of channels to emulate
   * @param num Number of channels (1-64, default: 16)
   */
  void SetNumChannels(uint8_t num);
  uint8_t GetNumChannels() const;

  /**
   * @brief Set the event generation rate
   * @param rate Events per second (default: 1000)
   */
  void SetEventRate(uint32_t rate);
  uint32_t GetEventRate() const;

  /**
   * @brief Set the data generation mode
   * @param mode Minimal or Full (default: Minimal)
   */
  void SetDataMode(EmulatorDataMode mode);
  EmulatorDataMode GetDataMode() const;

  /**
   * @brief Set the energy range for random generation
   * @param min Minimum energy value (default: 0)
   * @param max Maximum energy value (default: 16383)
   */
  void SetEnergyRange(uint16_t min, uint16_t max);
  std::pair<uint16_t, uint16_t> GetEnergyRange() const;

  /**
   * @brief Set waveform size for Full mode
   * @param size Number of samples (default: 0 = no waveform)
   */
  void SetWaveformSize(size_t size);
  size_t GetWaveformSize() const;

  /**
   * @brief Set random seed for reproducible tests
   * @param seed Random seed value
   */
  void SetSeed(uint64_t seed);

  // === Testing utilities ===
  void ForceError(const std::string& message);

 protected:
  // === IComponent callbacks ===
  bool OnConfigure(const nlohmann::json& config) override;
  bool OnArm() override;
  bool OnStart(uint32_t run_number) override;
  bool OnStop(bool graceful) override;
  void OnReset() override;

 private:
  // === Helper methods ===
  bool TransitionTo(ComponentState newState);
  void GenerationLoop();
  void CommandListenerLoop();
  void HandleCommand(const Command& cmd);

  // === State ===
  std::atomic<ComponentState> fState{ComponentState::Idle};
  mutable std::mutex fStateMutex;
  std::string fComponentId;

  // === Addresses ===
  std::vector<std::string> fOutputAddresses;

  // === Configuration ===
  uint8_t fModuleNumber{0};
  uint8_t fNumChannels{16};
  uint32_t fEventRate{1000};
  EmulatorDataMode fDataMode{EmulatorDataMode::Minimal};
  uint16_t fEnergyMin{0};
  uint16_t fEnergyMax{16383};
  size_t fWaveformSize{0};

  // === Run state ===
  std::atomic<uint32_t> fRunNumber{0};
  std::string fErrorMessage;
  std::atomic<uint64_t> fEventsProcessed{0};
  std::atomic<uint64_t> fBytesTransferred{0};
  std::atomic<uint64_t> fHeartbeatCounter{0};

  // === Threads ===
  std::unique_ptr<std::thread> fGenerationThread;
  std::atomic<bool> fRunning{false};
  std::atomic<bool> fShutdownRequested{false};

  // === Network components ===
  std::unique_ptr<Net::ZMQTransport> fTransport;
  std::unique_ptr<Net::DataProcessor> fDataProcessor;

  // === Random number generation ===
  std::mt19937_64 fRng;
  bool fSeedSet{false};
  uint64_t fSeed{0};

  // === Timestamp tracking ===
  double fCurrentTimestampNs{0.0};

  // === Command channel ===
  std::string fCommandAddress;
  std::unique_ptr<Net::ZMQTransport> fCommandTransport;
  std::unique_ptr<std::thread> fCommandListenerThread;
  std::atomic<bool> fCommandListenerRunning{false};
};

}  // namespace DELILA

#endif  // DELILA_COMPONENT_EMULATOR_HPP
